/*
Day 2: Indexing, Aggregating, Mapreduce
Increasing MongoDB’s query performance is the first item on today’s docket,
followed by some more powerful and complex grouped queries. Finally, we’ll
round out the day with some data analysis using mapreduce.
*/

//Indexing: When Fast isn't Fast Enough
// mongodb has several good data structures for indexing

populatePhones(800, 5550000, 5650000) // This could take a minute
db.phones.find().limit(2)

/*
{ "_id" : 18005550000, "components" : { "country" : 1, "area" : 800,
"prefix" : 555, "number" : 5550000 }, "display" : "+1 800-5550000" }
{ "_id" : 88005550001, "components" : { "country" : 8, "area" : 800,
"prefix" : 555, "number" : 5550001 }, "display" : "+8 800-5550001" }


Whenever a new collection is created, Mongo automatically creates an index
by the _id. These indexes can be found in the system.indexes collection. The following
query shows all indexes in the database:
*/
db.getCollectionNames().forEach(function(collection) {
print("Indexes for the " + collection + " collection:");
printjson(db[collection].getIndexes());
});

/*
most queries will include more fields than just the _id, so we need to make 
indexes on those fields.
gonna make a B-tree index on the display field. First, let's verify the index
will improve speed. first check a query without an index, the explain() method
is used to output details of a given operation. 
*/

db.phones.find({display: "+1 800-565001"}).
	explain("executionStats").executionStats

// "executionTimeMillisEstimate" : 40

/*
create an index by calling ensureIndex(fields, options) on the collection. 
The fields parameter is an object containing the fields to be indexed against.
he options parameter describes the type of index to make. In this case, 
we’re building a unique index on display that should just drop duplicate entries
*/

db.phones.ensureIndex(
	{ display: 1 },
	{ unique: true, dropDups: true }
)

//check the query time again. we get "executionTimeMillisEstimate" : 0
db.phones.find({display: "+1 800-565001"}).
	explain("executionStats").executionStats

/*
The executionTimeMillisEstimate changed from 52 to 0—an infinite improvement
(52 / 0)! Just kidding, but the query is now orders of magnitude faster.
Mongo is no longer doing a full collection scan but instead walking the tree
to retrieve the value. Importantly, scanned objects dropped from 109999 to
1—since it has become a single unique lookup.

explain() is useful function but it's only for testing specific query calls.
for normal test or production environment, you'll need system profiler.
*/

/////////////system profiler.
/*
set the profiling level to 2 (level 2 stores all queries; profiling level 1
stores only slower queries greater than 100 milliseconds) and then run find()
as normal.
*/

db.setProfilingLevel(2)
db.phones.find({ display: "+1 800-5650001"})

/*
This will create a new object in the system.profile collection, which you can read
as any other table to get information about the query, such as a timestamp
for when it took place and performance information (such as executionTimeMillis-
Estimate as shown). You can fetch documents from that collection like any
other:
*/

db.system.profile.find()
/*
This will return a list of objects representing past queries. This query, for
example, would return stats about execution times from the first query in
the list:
*/

db.system.profile.find()[0].execStats









